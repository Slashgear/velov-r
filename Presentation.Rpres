Projet BI - Les Vélovs
========================================================
author: Antoine CARON, Adrien Chaussende, Alexandre Galdéano, Cédric Ginot, Thomas Coquan, Sophie Perraud
date: Octobre 2015


Présentation générale
========================================================
L’idée principales : connaître les conditions d’utilisation des vélovs, notamment par rapport à la météo.

Récupération des données via trois webservices :
* État des velovs : Webservices de JCDecaux
* État de la météo : Webservices de Forecast.io
* Altitude des stations vélovs : Webservices de Google

Utilisation unique de l'Open-Data


Nos KPI
========================================================
* Quelle est l'influence de la météo sur l'utilisation des Velovs ?
* Quelle est l'influence d'une station en panne, vide ou pleine sur les stations voisines ?
* Identifier différents groupes de stations.
* Comment ont-été mis en place les stations bonus ?
* Quelles sont les stations les plus actives et les moins actives ?
* Identifier des facteurs de pannes et la récurrence de celle-ci.
* Quelles sont les horaires de forte activité ?
* Quel est l'influence des week-ends ...

Un projet en plusieurs étapes
========================================================

//TODO faire un shéma
Collecte des données par sh et CRON

Traitement des JSON en sql

Import des SQL dans l'ODS

ETL pour l'EDD (SQL et Talend)

Reporting R et QlikSense


Le Bonus
========================================================
type: sub-section
Nous nous sommes intéressé à la façon dont JCDECAUX avait groupé ses stations pour former:
- Les stations avec Bonus
- Les stations sans Bonus

Analyse de l'altitude des Stations
========================================================

```{r, echo=FALSE}
stations <- read.csv2("EDD/stations.csv", header = TRUE, sep = ";", quote = "\"")
faits <- read.csv2("EDD/fait.csv", header = TRUE, sep = ";", quote = "\"")
summary(subset(stations,select=c("ALTITUDE")))
```

Répartition des altitudes de stations
========================================================

```{r, echo=FALSE}
boxplot(stations$ALTITUDE,horizontal=T,main="Altitude des Stations")
```

Groupements par altitudes de stations
========================================================

```{r, echo=FALSE}
cl2 <- kmeans(stations$ALTITUDE, 2)
cl3 <- kmeans(stations$ALTITUDE, 3)
cl4 <- kmeans(stations$ALTITUDE, 4)
cl5 <- kmeans(stations$ALTITUDE, 5)
dunn2 <- cl2$betweenss/cl2$totss
dunn3 <- cl3$betweenss/cl3$totss
dunn4 <- cl4$betweenss/cl4$totss
dunn5 <- cl5$betweenss/cl5$totss
plot(stations$ALTITUDE, col = cl2$cluster,main="2 groupes d'altitude",sub=dunn2,ylab="Altitude en m")
```
***
```{r, echo=FALSE}
plot(stations$ALTITUDE, col = cl3$cluster,main="3 groupes d'altitude",sub=dunn3,ylab="Altitude en m")
```

Visualisation du groupement
========================================================

```{r, echo=FALSE}
require(ggmap)
require(mapproj)
mapImageData1 <- get_map(location = c(lon = 4.850000, lat = 45.750000),
                         source = "google",
                         zoom = 12)
```

```{r, echo=FALSE}
d <- data.frame(lat=stations$LONGITUDE,
                lon=stations$LATITUDE,cl2$cluster)
a <- ggmap(mapImageData1, extent = "panel")
a <- a + geom_point(data=d, aes(x = lat,y = lon), colour=cl2$cluster)
a <- a + ggtitle("Classement des stations en 2 groupes")
plot(a)
```
***
```{r, echo=FALSE}
d <- data.frame(lat=stations$LONGITUDE,
                lon=stations$LATITUDE,cl3$cluster)
a <- ggmap(mapImageData1, extent = "panel")
a <- a + geom_point(data=d, aes(x = lat,y = lon), colour=cl3$cluster)
a <- a + ggtitle("Classement des stations en 3 groupes")
plot(a)
```

Groupement par "Bonus" actuel
========================================================
```{r, echo=FALSE}
velov <- faits
bonus <- factor(velov$BONUS)
velov$BONUS <- as.integer(bonus)
velov <- aggregate(velov,by=list(velov$ID_STATION),FUN="mean")
velov <- subset(velov, select=c("ID_STATION", "BONUS"))
stationBonus <- merge(x = stations,y = velov)

d <- data.frame(lat=stationBonus$LONGITUDE,
                lon=stationBonus$LATITUDE,stationBonus$BONUS)
a <- ggmap(mapImageData1, extent = "panel",legend="topright")
a <- a + geom_point(data=d, aes(x = lat,y = lon),colour=stationBonus$BONUS)
a <- a + ggtitle("Stations avec Bonus")
plot(a)
```

Comparaison entre les deux groupements
========================================================

```{r, echo=FALSE}
plot(a)
```
***
```{r, echo=FALSE}
d <- data.frame(lat=stations$LONGITUDE,
                lon=stations$LATITUDE,cl2$cluster)
a <- ggmap(mapImageData1, extent = "panel")
a <- a + geom_point(data=d, aes(x = lat,y = lon), colour=cl2$cluster)
a <- a + ggtitle("Classement des stations en 2 groupes")
plot(a)
```

Vérifications
========================================================

```{r}
cor.test(cl2$cluster, stationBonus$BONUS)
```

Conclusion
========================================================

Le choix du bonus dépend donc uniquement que de l'altitude de la station.
Il reste à montrer que l'altitude impacte l'utilisation de la station.

Pour aller plus loin
========================================================
type: prompt
Grâce à cette collecte de données nous pourrions être en mesure de mettre en place un modèle prédictif afin de permettre aux usagers des Vélovs de déterminer à l'avance si un vélo ou emplacement sera disponible dans le futur.

Il serait intéressant de lier cela avec le projet Web "Lyon Vélov"
